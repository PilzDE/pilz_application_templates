<?xml version="1.0"?>

<!--
Copyright Â© 2018 Pilz GmbH & Co. KG

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<launch>

  <!-- The "sim" argument controls whether we connect to a Simulated or Real robot -->
  <arg name="sim" default="true" />

  <!-- Control a supported gripper, e.g. 'pg70'.
       Note: Please include the gripper model into your application URDF yourself. -->
  <arg name="gripper" value="" />

  <!-- Send urdf to parameter server -->
  <param name="robot_description"
         command="$(find xacro)/xacro --inorder '$(find prbt_default_application)/urdf/my_application.xacro'" />

  <!-- Start RViz visualization. Comment this on headless hardware, if you just want to run the driver -->
  <include file="$(find prbt_moveit_config)/launch/moveit_rviz.launch">
    <!-- put in your config file, once you saved it inside your package -->
    <arg name="rviz_config" value="$(find prbt_moveit_config)/launch/moveit.rviz" />
  </include>

  <!-- Bringup the planner including environment collision checking -->
  <include file="$(find prbt_moveit_config)/launch/move_group.launch">
    <arg name="fake_execution" value="$(arg sim)" /> <!-- do not change -->
    <arg name="load_robot_description" value="false" />
    <arg name="gripper" value="$(arg gripper)" />

    <arg name="pipeline" value="pilz_command_planner" /><!-- Choose planning pipeline -->
    <!-- <arg name="capabilities" value="" /> --> <!-- additional capabilites (space seperated) -->
    <!-- <arg name="disable_capabilities" value="" /> --> <!-- inhibit capabilites (space seperated) -->
  </include>

  <!-- The semantic description that corresponds to the URDF. -->
  <!-- <param name="robot_description_semantic" command="$(find xacro)/xacro -&#45;inorder
               $(find prbt_default_application)/config/prbt.srdf.xacro" /> -->

  <!-- Run the "real robot" interface nodes -->
  <!--   - this includes: robot_state, canopen, and sto nodes -->
  <group unless="$(arg sim)">
    <include file="$(find prbt_support)/launch/robot.launch">
      <arg name="load_robot_description" value="false" />
      <arg name="gripper" value="$(arg gripper)" />

      <!-- Safe-torque-off-input from the safety controller is read to brake the robot before power-off
           The signal is read via modbus and you can configure the modbus server ip -->
      <!-- <arg name="sto" value="pss4000" /> -->
      <!-- <arg name="sto_modbus_server_ip" value="192.168.0.10" /> -->

      <!-- You can additionally select the two safety functions below: -->
      <!-- Set braketest usage -->
      <arg name="has_braketest_support" value="true"/>
      <!-- Set operation mode support -->
      <arg name="has_operation_mode_support" default="true"/>

      <!-- Set the name of the config file for canopen_motor_node. If you want to change settings, copy the yaml
           file into your package and set canopen_config to your new config file path.
           See http://wiki.ros.org/canopen_chain_node for available configuration options. -->
      <!-- <arg name="canopen_config" value="$(find prbt_default_application)/config/manipulator_driver.yaml" /> -->

      <!-- If you defined more controllers, add them to this list -->
      <!-- <arg name="spawn_controllers"
           value="manipulator_joint_trajectory_controller manipulator_joint_state_controller" /> -->
    </include>
    <!-- Define additional controllers, see http://wiki.ros.org/joint_trajectory_controller?distro=melodic#Controller_configuration_examples -->
    <!-- <rosparam ns="prbt" command="load"
                   file="$(find prbt_default_application)/config/my_controller.yaml" /> -->

    <!-- To override a single parameter (e.g. name of can device), or define your own controllers,
         use rosparam override:-->
    <!-- <rosparam param="/prbt/driver/bus/device">can2</rosparam> -->

    <!-- Homing of pg70-gripper: Enable referencing procedure during init -->
    <!-- <rosparam param="/prbt/driver/nodes/prbt_gripper_finger_left_joint/dcf_overlay">
      {"6502" : "99", "6098" : "34"}
    </rosparam> -->
  </group>

  <!-- Run the robot simulator and action interface nodes -->
  <group if="$(arg sim)">
    <!-- Publish the robot state (tf transforms) -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />

    <!-- We do not have a robot connected, so publish fake joint states -->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
      <param name="/use_gui" value="false"/>
      <rosparam param="/source_list">[/move_group/fake_controller_joint_states]</rosparam>
    </node>

    <!-- We assume that no safety controller is connected, so we need to fake the corresponding interface -->
    <!--  - this includes: speed override -->
    <include file="$(find prbt_hardware_support)/launch/fake_safety_interface.launch" />
  </group>

  <!-- Joint limits (override information from URDF) -->
  <!-- <rosparam ns="robot_description_planning" command="load"
            file="$(find prbt_default_application)/config/joint_limits.yaml"/> -->

  <!-- Cartesian limits (position and velocities) -->
  <!-- <rosparam ns="robot_description_planning" command="load"
            file="$(find prbt_default_application)/config/cartesian_limits.yaml"/> -->

  <!-- startup application script with state-machine-based or similar procedural control -->
  <!-- <node name="my_application" pkg="prbt_default_application" type="myApplication.py" /> -->

</launch>
