<?xml version="1.0"?>

<!--
Copyright Â© 2018 Pilz GmbH & Co. KG

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<launch>

  <!-- The "sim" argument controls whether we connect to a Simulated or Real robot -->
  <arg name="sim" default="true" />
  
  <!-- Control a supported gripper, e.g. 'pg70' -->
  <arg name="gripper" default="" />

  <!-- Send urdf to parameter server -->
  <param name="robot_description"
         command="$(find xacro)/xacro --inorder '$(find prbt_default_application)/urdf/my_first_application.xacro'"/>

  <!-- Start RViz visualization. Comment this on headless hardware, if you just want to run the driver -->
  <include file="$(find prbt_moveit_config)/launch/moveit_rviz.launch">
    <!-- put in your config file, once you saved it inside your package -->
    <arg name="rviz_config" value="$(find prbt_moveit_config)/launch/moveit.rviz"/>
  </include>

  <!-- Bringup the planner including environment collision checking -->
  <include file="$(find prbt_moveit_config)/launch/move_group.launch">
    <arg name="fake_execution" value="$(arg sim)"/>
    <arg name="pipeline" value="pilz_command_planner" /><!-- Choose planning pipeline -->
    <arg name="load_robot_description" value="false" />
    <arg name="gripper" value="$(arg gripper)" />
    <!-- <arg name="capabilities" value="" /> --> <!-- additional capabilites (space seperated) -->
    <!-- <arg name="disable_capabilities" value="" /> --> <!-- inhibit capabilites (space seperated) -->
  </include>

  <!-- The semantic description that corresponds to the URDF.
       Options: default srdf / custom file -->
  <param name="robot_description_semantic" command="$(find xacro)/xacro --inorder
               $(find prbt_moveit_config)/config/prbt.srdf.xacro gripper:=$(arg gripper)" >
  <!-- <param name="robot_description_semantic" command="$(find xacro)/xacro --inorder
               $(find prbt_default_application)/config/prbt.srdf.xacro" /> -->

  <!-- Run the "real robot" interface nodes -->
  <!--   - this includes: robot_state, canopen, and sto nodes -->
  <group unless="$(arg sim)">
    <include file="$(find prbt_support)/launch/robot.launch">
      <arg name="load_robot_description" value="false" />
      <arg name="gripper" value="$(arg gripper)" />

      <!-- Safe-torque-off-input from the safety controller is read to do brake robot before stop 1
           The signal is read via modbus and you can configure the modbus server ip -->
      <!-- <arg name="sto" value="pnoz" /> -->
      <!-- <arg name="sto_modbus_server_ip" value="192.168.0.10" /> -->

      <!-- Set the name of the config file for canopen_motor_node. If you want to change settings, copy the yaml
           file into your package and set canopen_config to your new config file path -->
      <!-- <arg name="canopen_config" value="$(find pilz_tutorials)/config/manipulator_driver.yaml" /> -->

      <!-- If you defined more controllers, add them to this list -->
      <!-- <arg name="spawn_controllers"
           value="manipulator_joint_trajectory_controller manipulator_joint_state_controller" /> -->
    </include>
    <!-- To override a single parameter (e.g. name of can device), or define your own controllers,
         use rosparam override:-->
    <!-- <rosparam param="/prbt/driver/bus/device">can2</rosparam> -->
  </group>

  <!-- Run the robot simulator and action interface nodes -->
  <group if="$(arg sim)">
    <!-- Publish the robot state (tf transforms) -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />

    <!-- We do not have a robot connected, so publish fake joint states -->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
      <param name="/use_gui" value="false"/>
      <rosparam param="/source_list">[/move_group/fake_controller_joint_states]</rosparam>
    </node>
  </group>

  <!-- Override joint limits (override information from URDF) -->
  <!-- <rosparam ns="robot_description_planning" command="load"
            file="$(find prbt_default_application)/config/joint_limits.yaml"/> -->

  <!-- Override cartesian limits -->
  <!-- <rosparam ns="robot_description_planning" command="load"
            file="$(find prbt_default_application)/config/cartesian_limits.yaml"/> -->

</launch>

